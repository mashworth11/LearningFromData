#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Thu Nov 29 15:00:25 2018

@author: markashworth
"""

"""
Program to be used to answer the PLA questions (Q7-10) in Homework 1 of 
the Learning from Data course
"""
import random
import matplotlib.pyplot as plt
import numpy as np

class generateLabels(object):
    """
    Our output data (or labels) are generated by using the target function 
    (evalPoint) on each point. Target function is created by picking two 
    random points x1 and x2, and drawing the line that passes through them.
    """
    def __init__(self, N):
        """
        N is the sample size
        x1 is the first point 
        x2 is the second point
        """
        self.N = N
        self.x1 = [random.choice([-1,1])*random.random(), random.choice([-1,1])*random.random()]
        self.x2 = [random.choice([-1,1])*random.random(), random.choice([-1,1])*random.random()]
        self.m, self.b = self.linearEq()
        self.mappedVec = self.mapVector() # Dict of input data (keys) and labels (values)
        
    def linearEq(self):
        """
        Generate linear equation based on points
        """
        m = (self.x2[1] - self.x1[1])/(self.x2[0] - self.x1[0])
        b = self.x1[1] - m*self.x1[0]
        return m, b
    
    def visual(self):
        """
        Visualisation based used equation on x-coordinates -1, and 1. 
        """
        y1 = self.m*-1 + self.b 
        y2 = self.m*1 + self.b
        plt.plot([-1, 1], [y1, y2], 'r-')
        plt.xlim(-1, 1); plt.ylim(-1, 1)
    
    def evalPoint(self, x): # TARGET FUNCTION
        """
        Evaluate a single data point, x, given the linear equation splitting up
        the domain. This evalutaion is what constitutes the TARGET FUNCTION. 
        """
        if  x[1] < self.m*x[0] + self.b:
            return -1
        else:
            return 1
    
    def mapVector(self):
        """
        Evalutaion of N vector of input data points based on the target function. That is, 
        given some input data we want to map outputs (or labels) to them. The mapping
        is expressed as a dictionary with keys of input points and values of outputs.
        """
        return {i:self.evalPoint(i) for i in \
               [(random.choice([-1,1])*random.random(), random.choice([-1,1])*random.random())\
               for i in range(self.N)]}
    
    
class PLA(object):
    def __init__(self, N, w = None):
        """
        Want to create a perceptron learning algorithm class, that finds the 
        'optimal' hypothesis function given the data.
        N is the number of training points
        Default value for weights initially is zero, unless we told otherwise.
        """
        self.N = N 
        self.w = w if w is not None else np.zeros(3) # weights (w0, w1, ..., wd), only considering d = 2
        self.data = generateLabels(self.N) # classification labels for input data
        self.mappedVec = self.createInitMapping()
    
    def createInitMapping(self):
        """
        Generate the initial mapping between input data and output such that every
        initial input is initially mapped to 0 and is therefore by construction
        misclassified. 
        """
        return {key:0 for key in self.data.mappedVec.keys()}
            
    def evalPoints(self):
        """
        Given the weighting function evaluate output given the input data.
        """
        sign = lambda x: x and (-1 if x < 0 else 1)
        for i in self.mappedVec:            
            self.mappedVec[i] = sign(np.matmul(self.w, [1]+list(i)))
    
    def pickMisclassified(self):     
        """
        Picks a misclassified point where a misclassified point is any point
        who's output does not match that of the target function mapping output.
        """
        self.evalPoints()
        misclassified = []
        for i in self.mappedVec:
            if self.mappedVec[i] != self.data.mappedVec[i]:
                misclassified.append(i)
        return random.choice(misclassified)
    
    def updateWeights(self):
        """
        Update weights according the perceptron learning algorithm update rule
        (see page pg.7 from Learning from Data bookie wookie).
        """
        misclassified = self.pickMisclassified()
        for i in misclassified:
            self.w += self.data.mappedVec[misclassified]*np.array([1] + list(misclassified))
 
           
def runPLA(pla_object):
    """
    Function to run the perceptron learning algorithm (PLA) to find g. Function takes
    in PLA object.
    """
    k = 0
    while True:
        try:
            pla_object.updateWeights()
            k += 1
        except IndexError: # breaks when no more misclassified points
            break    
    return k


def PLAsimulation(N, w=None):
    """
    Function to simulate the perceptron learning algorithm for a sample size 
    of N over 1000 runs. 
    """
    iterations = []
    for i in range(1000):
        iterations.append(runPLA(PLA(N, w = None)))
    return np.mean(iterations)
    
        
        
        
    
    
    
    
    
    
    
    
                    